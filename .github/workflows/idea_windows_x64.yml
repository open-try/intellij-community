# .github/workflows/idea_windows_x64.yml
name: IntelliJ IDEA â€” Windows x64 (manual)

on:
  # Manual trigger only
  workflow_dispatch: {}

# Prevent accidental parallel builds of the same ref
concurrency:
  group: idea-win64-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: read

jobs:
  build-windows-x64:
    name: Build IDEA.exe (Windows x64)
    # Only allow manual runs on master
    if: github.ref == 'refs/heads/master'
    runs-on: ubuntu-latest
    timeout-minutes: 60

    env:
      PRODUCT: intellij_idea
      TARGET_OS: windows
      TARGET_ARCH: x64
      ARTIFACTS_DIR: out/idea-ce/artifacts

    steps:
      - name: Checkout fork (intellij-community)
        uses: actions/checkout@v4.2.2

      - name: Compute SNAPSHOT version tag
        id: versioning
        shell: bash
        run: |
          set -euo pipefail
          # Date in UTC, pattern YYYYMMDD
          BUILD_DATE="$(date -u +%Y%m%d)"
          echo "BUILD_DATE=$BUILD_DATE" | tee -a "$GITHUB_ENV"

          # Read version from top-level build.txt, e.g. 261.SNAPSHOT
          VERSION_RAW="$(tr -d '\r\n' < build.txt)"
          echo "VERSION_RAW=$VERSION_RAW" | tee -a "$GITHUB_ENV"

          # Replace SNAPSHOT with date -> YYYYMMDD
          VERSION_TAG="${VERSION_RAW/SNAPSHOT/${BUILD_DATE}}"
          echo "VERSION_TAG=$VERSION_TAG" | tee -a "$GITHUB_ENV"

          # Final zip filename per your schema: windows-exe-version-unsigned.zip
          ZIP_NAME="windows-exe-${VERSION_TAG}-unsigned.zip"
          echo "ZIP_NAME=$ZIP_NAME" | tee -a "$GITHUB_ENV"

      - name: Checkout JetBrains/android (same ref)
        uses: actions/checkout@v4.2.2
        with:
          repository: JetBrains/android
          path: android
          ref: ${{ github.ref }}

      - name: Build Docker environment
        shell: bash
        run: |
          docker build . \
            --target "${PRODUCT}" \
            --tag "${PRODUCT}"

      - name: Build Windows x64 .exe via Docker
        shell: bash
        run: |
          # Build only Windows + x64.
          # 'intellij.build.target.os' and 'intellij.build.target.arch' are official build properties.
          # Optionally skip the Windows .zip step to save time/artifacts.
          docker run --rm \
            --user "$(id -u)" \
            --volume "${PWD}:/community" \
            "${PRODUCT}" \
            -Dintellij.build.target.os="${TARGET_OS}" \
            -Dintellij.build.target.arch="${TARGET_ARCH}" \
            -Dintellij.build.skip.build.steps=windows_zip_archive

      - name: List produced files (debug)
        if: always()
        shell: bash
        run: |
          echo "Contents of ${ARTIFACTS_DIR}:"
          ls -lah "${ARTIFACTS_DIR}" || true

      - name: Generate SHA-256 checksums for .exe (+ SPDX if present)
        shell: bash
        run: |
          set -euo pipefail
          checksum() {
            local f="$1"
            if [ "$(uname)" = "Darwin" ]; then
              shasum --algorithm 256 --binary "$f"
            else
              sha256sum --binary "$f"
            fi > "$f.sha256"
          }
          cd "${ARTIFACTS_DIR}"
          shopt -s nullglob
          for it in *.exe; do echo "checksum: $it"; checksum "$it"; done
          for it in *.exe.spdx.json; do echo "checksum: $it"; checksum "$it"; done

      - name: Package unsigned Windows exe into versioned zip
        shell: bash
        run: |
          set -euo pipefail
          cd "${ARTIFACTS_DIR}"
          ZIP_PATH="${{ github.workspace }}/${ZIP_NAME}"

          # Include the unsigned .exe, its checksum(s), and SPDX (if present)
          # If spdx or sha256 are missing, zip will warn about no matches; ensure exe exists.
          ls -l *.exe
          zip -9 -y "$ZIP_PATH" *.exe *.spdx.json *.sha256 2>/dev/null || \
          zip -9 -y "$ZIP_PATH" *.exe

          echo "ZIP_PATH=$ZIP_PATH" >> "$GITHUB_ENV"

      - name: Upload versioned zip
        uses: actions/upload-artifact@v4.4.3
        with:
          name: ${{ env.ZIP_NAME }}
          if-no-files-found: error
          retention-days: 1
          path: ${{ env.ZIP_PATH }}

      - name: Cleanup (Docker, workspace)
        if: always()
        shell: bash
        run: |
          set -euxo pipefail

          echo "::group::Docker cleanup"
          # Stop & remove any leftover containers (best effort)
          docker ps -aq | xargs -r docker rm -f || true
          # Remove image we created (PRODUCT tag) and everything else unused
          docker images --format '{{.Repository}}:{{.Tag}}' | grep -E "^${PRODUCT}:" | xargs -r docker rmi -f || true
          docker builder prune -af || true
          docker image prune -af || true
          docker container prune -f || true
          docker volume prune -f || true
          echo "::endgroup::"

          echo "::group::Workspace cleanup"
          # Remove build outputs and auxiliary checkouts
          rm -rf "${ARTIFACTS_DIR}" || true
          rm -rf android out || true

          # Deep clean the repo workspace (including hidden files like .git)
          # Do this at the very end so it doesn't interfere with upload steps
          git clean -ffdx || true
          echo "::endgroup::"
